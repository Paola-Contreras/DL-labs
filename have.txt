    # def Follow(self):
    #     SLRG = self.grammar.SLR_Grammar
    #     labels = list(SLRG.keys())
    #     followed = {k: set() for k in labels}
    #     followed[labels[0]].add('$')
    #     #print(SLRG)
    #     for k, v in SLRG.items():
    #         productions = v.split('|')
    #         for production in productions:
    #             production = production.strip()
    #             symbols = production.split()
    #             for i in range(len(symbols) - 1):
    #                 if symbols[i] in labels:
    #                     if symbols[i + 1] in labels:
    #                         followed[symbols[i]].update(self.First(symbols[i + 1:]))
    #                         followed[symbols[i]].discard('e')
    #                     else:
    #                         followed[symbols[i]].add(symbols[i + 1])
        
    #     #print(followed)



     def GoTo(self):
        SLRG= self.Aumented_SLRG
        simbol = self.symbols
        nt = self.grammar.production.nonTerminals
        nt = [value for value in nt.values()]
        t = self.grammar.tokens.T
        produc =[]
        stack = []
        tempItem = []
        transitions = []
        
        #print(simbol)
        for k ,v in SLRG.items():
            for j in v:
                produc.append(f'{k} -> . {j}')
        self.UpdateProd = produc
        start = produc[0]
        #print(produc)
        Fc = self.Closure(start)
        stack.append(Fc)

        for sym in simbol:
            tempItem = []
            new_items_added = False
            for element in stack:
                print(element,'NEW')
                print(sym,'CAMBIO')
                for prod in element:
                    print(prod,'EVAl')
                    p = prod.split(' ')
                    dot_pos = p.index('.')
                    if dot_pos + 1 < len(p):
                        sigue = p[dot_pos+1]
                    if sym == sigue:
                        dot_ = p.index('.')
                        if dot_ + 1 < len(p):
                            # Intercambiar los elementos adyacentes al punto
                            p[dot_], p[dot_ + 1] = p[dot_ + 1], p[dot_]
                        
                        dot_new = p.index('.')
                        if dot_new + 1 < len(p):
                            new = p[dot_new+1]
                            if new in t:
                                n = ' '.join(map(str, p))
                                tempItem.append(n)
                                new_items_added = True
                            elif new in nt:
                                n = ' '.join(map(str, p))
                                c = self.Closure(n)
                                for i in c:
                                    if i not in tempItem:
                                        tempItem.append(i)
                                        new_items_added = True
                                #print(c,'MISSING')
                        elif p[-1] == '.':
                            n = ' '.join(map(str, p))
                            tempItem.append(n)
                            new_items_added = True
                            




                        #print(n,'cam')
                        #print(sym,p)
            if new_items_added:
                stack.append(tempItem)
            #print(tempItem,'alo')
            # print()
            # for i in stack:
            #     print (i)
            #print(stack,'FIN')
        print(len(stack))



def Closure(self,production):
        closures = []
        nt = self.grammar.production.nonTerminals
        nt = [value for value in nt.values()]
        t = self.grammar.tokens.T
        label_eval = []
        already = []

        splited = production.split(' ')
        dot_pos = splited.index('.')
        
        #print(production)
        #print(splited)
        # print(self.UpdateProd)
        label_eval.append(splited[dot_pos+1])
        already.append(splited[dot_pos+1])
        closures.append(production)

        while len(label_eval) > 0:
            in_Nt = label_eval.pop()
            if in_Nt in t:
                #print('Es un terminal, se termina')
                continue
            elif in_Nt in nt:
                #print('Es un no terminal')
                #print(in_Nt,'l')
                for P in self.UpdateProd:
                    P = P.split(' -> ')
                    #print(P)
                    if in_Nt == P[0]:
                        new_eval = P[1]
                        #print(P[1],'PROD')  
                        dot_index = new_eval.index('.')
                        next_character = new_eval[dot_index + 2]
                        closures.append(f'{in_Nt} -> {new_eval}')
                        if next_character not in already:
                            already.append(next_character)
                            label_eval.append(next_character)
                        
        
        #print(closures)
        return closures